import fs from "node:fs/promises";
import path from "node:path";

function toTitle(value) {
  return value
    .split(/[-_]/)
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join(" ");
}

function pickPreferences(report, config = {}) {
  const resultById = Object.fromEntries(report.categories.map((item) => [item.id, item]));

  const namingPreference = resultById.naming?.preferences?.namingStyle || "camelCase";
  const fileNaming = resultById.naming?.preferences?.fileNamingStyle || "kebab-case";
  const httpClient =
    config.allowedPatterns?.httpClient || resultById.patterns?.preferences?.httpClient || "fetch";
  const asyncStyle =
    config.allowedPatterns?.asyncStyle || resultById.patterns?.preferences?.asyncStyle || "async-await";
  const importStyle = resultById.patterns?.preferences?.importStyle || "esm";

  return {
    namingPreference,
    fileNaming,
    httpClient,
    asyncStyle,
    importStyle
  };
}

function markdownRules(preferences) {
  const asyncPhrase = preferences.asyncStyle === "then-chains" ? ".then() chains" : "async/await";

  return `# Project Coding Standards (Generated by vibeclean)

## Naming Conventions
- Use ${preferences.namingPreference} for variables and functions
- Use PascalCase for components and classes
- Use ${preferences.fileNaming} for file names

## Patterns
- Use ${preferences.httpClient} for all HTTP requests
- Use ${asyncPhrase} for all asynchronous code
- Use one module style consistently (${preferences.importStyle === "cjs" ? "CommonJS" : "ES modules"})

## Error Handling
- Always wrap risky async operations in try/catch
- Never use empty catch blocks
- Do not catch-and-log only; rethrow or return typed failures

## Imports
- Prefer ${preferences.importStyle === "cjs" ? "require/module.exports" : "import/export"}
- Keep import style consistent (default vs named) per library

## Code Hygiene
- No console.log in production code (use a logger utility)
- No TODO comments left behind in committed code
- No hardcoded localhost URLs or placeholder credentials
- No commented-out code blocks
`;
}

function cursorRules(preferences) {
  const asyncPhrase = preferences.asyncStyle === "then-chains" ? ".then() chains" : "async/await";

  return `# .cursorrules generated by vibeclean

You are working on a codebase with strict consistency standards.

- Naming: ${preferences.namingPreference} for functions/variables, PascalCase for components.
- File names: ${preferences.fileNaming}.
- HTTP client: ${preferences.httpClient} only.
- Async style: ${asyncPhrase} only.
- Module system: ${preferences.importStyle === "cjs" ? "CommonJS" : "ES modules"} only.
- Error handling: no empty catch blocks, no catch-and-log-only handlers.
- Hygiene: avoid console logs, TODO leftovers, placeholders, and commented-out code.
`;
}

function claudeRules(preferences) {
  return `# CLAUDE.md (generated by vibeclean)

## Repository Standards

1. Keep naming consistent:
- ${preferences.namingPreference} for variables/functions
- PascalCase for components/classes
- ${preferences.fileNaming} for filenames

2. Keep implementation patterns consistent:
- Use ${preferences.httpClient} for HTTP requests
- Use ${preferences.asyncStyle === "then-chains" ? ".then() chains" : "async/await"} for async flows
- Keep module syntax consistent (${preferences.importStyle === "cjs" ? "CommonJS" : "ES Modules"})

3. Keep error handling explicit:
- Use try/catch around async boundaries
- Avoid empty catch blocks
- Do not swallow errors after logging

4. Keep codebase clean:
- Remove TODO/FIXME placeholders before final output
- Avoid console logging unless explicitly requested
- Never commit hardcoded localhost URLs, keys, or dummy credentials
`;
}

export async function generateRulesFiles(report, options = {}) {
  const preferences = pickPreferences(report, options.config);
  const writes = [];

  const rulesPath = path.join(options.rootDir, ".vibeclean-rules.md");
  writes.push(
    fs.writeFile(rulesPath, markdownRules(preferences), "utf8").then(() => ({
      type: "rules",
      path: rulesPath
    }))
  );

  if (options.cursor) {
    const cursorPath = path.join(options.rootDir, ".cursorrules");
    writes.push(
      fs.writeFile(cursorPath, cursorRules(preferences), "utf8").then(() => ({
        type: "cursor",
        path: cursorPath
      }))
    );
  }

  if (options.claude) {
    const claudePath = path.join(options.rootDir, "CLAUDE.md");
    writes.push(
      fs.writeFile(claudePath, claudeRules(preferences), "utf8").then(() => ({
        type: "claude",
        path: claudePath
      }))
    );
  }

  const generated = await Promise.all(writes);
  return {
    generated,
    summary: generated.map((item) => `${toTitle(item.type)}: ${item.path}`).join("\n")
  };
}

