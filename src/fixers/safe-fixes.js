import fs from "node:fs/promises";

const TODO_LINE_RE = /^\s*\/\/\s*(TODO|FIXME|HACK|XXX)\b/i;
const AI_COMMENT_LINE_RE = /^\s*\/\/\s*(AI generated|Generated by|Created by Copilot)\b/i;
const NOISY_CONSOLE_LINE_RE = /^\s*console\.(log|debug|trace)\s*\(.*\)\s*;?\s*$/;
const CODE_LIKE_COMMENT_RE =
  /^\s*\/\/.*(?:[;{}()[\]=]|\b(const|let|var|if|for|while|return|import|export|function|class)\b)/;

function identifyCommentedCodeLines(lines) {
  const removable = new Set();
  let streak = [];

  const flush = () => {
    if (streak.length >= 3) {
      for (const lineIndex of streak) {
        removable.add(lineIndex);
      }
    }
    streak = [];
  };

  for (let i = 0; i < lines.length; i += 1) {
    if (CODE_LIKE_COMMENT_RE.test(lines[i])) {
      streak.push(i);
      continue;
    }
    flush();
  }
  flush();

  return removable;
}

function transformContent(content) {
  const lines = content.split("\n");
  const commentedCodeLines = identifyCommentedCodeLines(lines);

  const stats = {
    removedTodoLines: 0,
    removedCommentedCodeLines: 0,
    removedConsoleLines: 0,
    filesChanged: 0
  };

  const kept = [];
  for (let i = 0; i < lines.length; i += 1) {
    const line = lines[i];

    if (commentedCodeLines.has(i)) {
      stats.removedCommentedCodeLines += 1;
      continue;
    }

    if (TODO_LINE_RE.test(line) || AI_COMMENT_LINE_RE.test(line)) {
      stats.removedTodoLines += 1;
      continue;
    }

    if (NOISY_CONSOLE_LINE_RE.test(line)) {
      stats.removedConsoleLines += 1;
      continue;
    }

    kept.push(line);
  }

  const trimmed = [];
  let blankStreak = 0;
  for (const line of kept) {
    if (line.trim() === "") {
      blankStreak += 1;
      if (blankStreak > 2) {
        continue;
      }
    } else {
      blankStreak = 0;
    }
    trimmed.push(line);
  }

  const nextContent =
    content.endsWith("\n") || content.length === 0 ? `${trimmed.join("\n")}\n` : trimmed.join("\n");
  const changed = nextContent !== content;
  if (changed) {
    stats.filesChanged = 1;
  }

  return {
    changed,
    content: nextContent,
    stats
  };
}

export async function applySafeFixes(files) {
  const updates = [];
  const totals = {
    filesChanged: 0,
    removedTodoLines: 0,
    removedCommentedCodeLines: 0,
    removedConsoleLines: 0
  };

  for (const file of files) {
    const result = transformContent(file.content);
    if (!result.changed) {
      continue;
    }

    updates.push(
      fs.writeFile(file.path, result.content, "utf8").then(() => {
        file.content = result.content;
      })
    );

    totals.filesChanged += result.stats.filesChanged;
    totals.removedTodoLines += result.stats.removedTodoLines;
    totals.removedCommentedCodeLines += result.stats.removedCommentedCodeLines;
    totals.removedConsoleLines += result.stats.removedConsoleLines;
  }

  await Promise.all(updates);
  return totals;
}

