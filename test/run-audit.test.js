import test from "node:test";
import assert from "node:assert/strict";
import fs from "node:fs/promises";
import os from "node:os";
import path from "node:path";
import { writeBaselineSnapshot } from "../src/baseline.js";
import { runAudit } from "../src/index.js";
import { renderMarkdownReport } from "../src/markdown-report.js";

async function withTempProject(fn) {
  const root = await fs.mkdtemp(path.join(os.tmpdir(), "vibeclean-test-"));
  try {
    await fn(root);
  } finally {
    await fs.rm(root, { recursive: true, force: true });
  }
}

test("runAudit handles empty projects", async () => {
  await withTempProject(async (root) => {
    const result = await runAudit(root, { version: "1.0.0" });
    assert.equal(result.report.fileCount, 0);
    assert.equal(result.report.totalIssues, 0);
    assert.match(result.report.overallMessage, /No JS\/TS source files found/);
  });
});

test("runAudit analyzes source files and returns categories", async () => {
  await withTempProject(async (root) => {
    await fs.mkdir(path.join(root, "src"), { recursive: true });
    await fs.writeFile(
      path.join(root, "src", "index.js"),
      "export async function main() { return fetch('http://localhost:3000').then(r => r.json()); }\n",
      "utf8"
    );

    const result = await runAudit(root, { version: "1.0.0" });
    assert.equal(result.report.fileCount, 1);
    assert.ok(result.report.categories.length >= 4);
    assert.ok(result.report.totalIssues >= 0);
  });
});

test("runAudit generates rules files", async () => {
  await withTempProject(async (root) => {
    await fs.mkdir(path.join(root, "src"), { recursive: true });
    await fs.writeFile(
      path.join(root, "src", "app.js"),
      "export function runTask() { console.log('hi'); }\n",
      "utf8"
    );

    const result = await runAudit(root, {
      version: "1.0.0",
      rules: true,
      cursor: true,
      claude: true
    });

    assert.equal(result.generatedRules.length, 3);

    const rulesPath = path.join(root, ".vibeclean-rules.md");
    const cursorPath = path.join(root, ".cursorrules");
    const claudePath = path.join(root, "CLAUDE.md");

    const [rulesContent, cursorContent, claudeContent] = await Promise.all([
      fs.readFile(rulesPath, "utf8"),
      fs.readFile(cursorPath, "utf8"),
      fs.readFile(claudePath, "utf8")
    ]);

    assert.match(rulesContent, /Project Coding Standards/);
    assert.match(cursorContent, /generated by vibeclean/);
    assert.match(claudeContent, /Repository Standards/);
  });
});

test("runAudit applies safe fixes when fix mode is enabled", async () => {
  await withTempProject(async (root) => {
    await fs.mkdir(path.join(root, "src"), { recursive: true });
    const filePath = path.join(root, "src", "cleanup.js");
    await fs.writeFile(
      filePath,
      [
        "// TODO: remove me",
        "export function runTask() {",
        "  console.log('debug');",
        "  // const stale = true;",
        "  // if (stale) {",
        "  //   return null;",
        "  // }",
        "  return 1;",
        "}"
      ].join("\n"),
      "utf8"
    );

    const result = await runAudit(root, { version: "1.0.0", fix: true });
    assert.ok(result.report.fixesApplied.filesChanged >= 1);
    assert.ok(result.report.fixesApplied.removedTodoLines >= 1);
    assert.ok(result.report.fixesApplied.removedConsoleLines >= 1);

    const next = await fs.readFile(filePath, "utf8");
    assert.doesNotMatch(next, /TODO/i);
    assert.doesNotMatch(next, /console\.log/);
    assert.doesNotMatch(next, /const stale/);
  });
});

test("runAudit reports quality gate failures", async () => {
  await withTempProject(async (root) => {
    await fs.mkdir(path.join(root, "src"), { recursive: true });
    await fs.writeFile(
      path.join(root, "src", "api.js"),
      "export const endpoint = 'http://localhost:3000';\n",
      "utf8"
    );

    const result = await runAudit(root, {
      version: "1.0.0",
      failOn: "high",
      maxIssues: 0
    });

    assert.equal(result.report.passedGates, false);
    assert.ok(result.report.gateFailures.length >= 1);
  });
});

test("profile cli suppresses console leftovers in bin files", async () => {
  await withTempProject(async (root) => {
    await fs.mkdir(path.join(root, "bin"), { recursive: true });
    await fs.writeFile(
      path.join(root, "bin", "tool.js"),
      "export function run() { console.log('ok'); }\n",
      "utf8"
    );

    const appResult = await runAudit(root, { version: "1.0.0", profile: "app" });
    const appLeftovers = appResult.report.categories.find((item) => item.id === "leftovers");
    assert.ok((appLeftovers?.metrics?.consoleCount || 0) >= 1);

    const cliResult = await runAudit(root, { version: "1.0.0", profile: "cli" });
    const cliLeftovers = cliResult.report.categories.find((item) => item.id === "leftovers");
    assert.equal(cliLeftovers?.metrics?.consoleCount || 0, 0);
  });
});

test("baseline compare reports regressions", async () => {
  await withTempProject(async (root) => {
    await fs.mkdir(path.join(root, "src"), { recursive: true });
    const filePath = path.join(root, "src", "feature.js");
    await fs.writeFile(filePath, "export const value = 1;\n", "utf8");

    const cleanRun = await runAudit(root, { version: "1.0.0" });
    await writeBaselineSnapshot(root, ".vibeclean-baseline.json", cleanRun.report);

    await fs.writeFile(filePath, "export const value = 1; // TODO: revisit\n", "utf8");
    const compared = await runAudit(root, {
      version: "1.0.0",
      baseline: true,
      baselineFile: ".vibeclean-baseline.json"
    });

    assert.ok(compared.report.baselineComparison);
    assert.equal(compared.report.passedGates, false);
    assert.ok(compared.report.gateFailures.some((line) => /Baseline regression/.test(line)));
  });
});

test("markdown report renderer outputs PR-friendly content", async () => {
  await withTempProject(async (root) => {
    await fs.mkdir(path.join(root, "src"), { recursive: true });
    await fs.writeFile(
      path.join(root, "src", "index.js"),
      "export async function main() { return fetch('http://localhost:3000').then(r => r.json()); }\n",
      "utf8"
    );

    const result = await runAudit(root, { version: "1.0.0" });
    const markdown = renderMarkdownReport(result.report);

    assert.match(markdown, /# Vibeclean PR Report/);
    assert.match(markdown, /## Category Summary/);
    assert.match(markdown, /\*\*Quality Gates:\*\*/);
  });
});
